#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"

// Network topology
//
//       10.1.1.0       10.1.2.0
// n0 -------------- n1..........n2
//    point-to-point
//

using namespace ns3;

NS_LOG_COMPONENT_DEFINE("P2P-LAB1");

int main(int argc, char *argv[])
{
    std::string socketType = "ns3::TcpSocketFactory";

    CommandLine cmd;
    cmd.Parse(argc, argv);

    NodeContainer nodes;
    nodes.Create(3);

    InternetStackHelper stack;
    stack.Install(nodes);

    PointToPointHelper p2p1;
    p2p1.SetDeviceAttribute("DataRate", StringValue("5Mbps"));
    p2p1.SetChannelAttribute("Delay", StringValue("1ms"));

    Ipv4AddressHelper address;
    address.SetBase("10.1.1.0", "255.255.255.0");

    NetDeviceContainer devices;
    devices = p2p1.Install(nodes.Get(0), nodes.Get(1));
    Ipv4InterfaceContainer interfaces = address.Assign(devices);

    devices = p2p1.Install(nodes.Get(1), nodes.Get(2));
    address.SetBase("10.1.2.0", "255.255.255.0");
    interfaces = address.Assign(devices);

    Ptr<RateErrorModel> em = CreateObject<RateErrorModel>();

    //Introduce error model to drop packets
    em->SetAttribute("ErrorRate", DoubleValue(0.00002));
    devices.Get(1)->SetAttribute("ReceiveErrorModel", PointerValue(em));

    Ipv4GlobalRoutingHelper::PopulateRoutingTables();

    uint32_t payloadSize = 1448;
    OnOffHelper onoff(socketType, Ipv4Address::GetAny());

    //Generate traffic
    onoff.SetAttribute("OnTime", StringValue("ns3::ConstantRandomVariable[Constant=1]"));

    onoff.SetAttribute("OffTime", StringValue("ns3::ConstantRandomVariable[Constant=0]"));

    onoff.SetAttribute("PacketSize", UintegerValue(payloadSize));

    onoff.SetAttribute("DataRate", StringValue("50Mbps")); //bit/s

    uint16_t port = 7;

    //1. Install receiver (for packetsink) on node 2
    Address localAddress1(InetSocketAddress(Ipv4Address::GetAny(), port));
    PacketSinkHelper packetSinkHelper1(socketType, localAddress1);
    ApplicationContainer sinkApp1 = packetSinkHelper1.Install(nodes.Get(2));
    sinkApp1.Start(Seconds(0.0));
    sinkApp1.Stop(Seconds(10));

    //2. Install sender app on node 0
    ApplicationContainer apps;
    AddressValue remoteAddress(InetSocketAddress(interfaces.GetAddress(1), port));
    onoff.SetAttribute("Remote", remoteAddress);
    apps.Add(onoff.Install(nodes.Get(0)));
    apps.Start(Seconds(1.0));
    apps.Stop(Seconds(10));

    Simulator::Stop(Seconds(10));

    //Generate trace file
    AsciiTraceHelper ascii;
    p2p1.EnableAsciiAll(ascii.CreateFileStream("P2ptracefile.tr"));

    //Run the simulator
    Simulator::Run();

    Simulator::Destroy();

    return 0;
}
/*
7. Write a program for error detecting code using CRC-CCITT (16- bits).
*/

import java.util.Scanner;

class CRC {

    static String xor(String a, String b) {

        StringBuilder stringBuilder = new StringBuilder();
        int len = Math.min(a.length(), b.length());
        for (int i = 0; i < len; i++) {
            if (a.charAt(i) == b.charAt(i)) {
                stringBuilder.append('0');
            } else {
                stringBuilder.append('1');
            }
        }
        return stringBuilder.toString();
    }

    static String divide(String dividend, String divisor) {
        int divisorLength = divisor.length();
        int dividendLength = dividend.length();
        while (dividendLength >= divisorLength) {
            String temp;
            if (dividend.charAt(0) == '1')
                temp = xor(divisor, dividend.substring(0, divisorLength));
            else
                temp = dividend.substring(0, divisorLength);
            dividend = temp.substring(1) + dividend.substring(divisorLength);
            dividendLength -= 1;
        }
        return dividend;
    }

    static String generateCodeWord(String message, String generator) {
        int msgLength = message.length();
        int gtrLength = generator.length();
        // Right pad the message String to make total length as (msgLength+gtrLength-1)
        // Put the formatted String in new variable
        String dividend = String.format("%-" + (msgLength + gtrLength - 1) + "s", message).replace(' ', '0');

        String remainder = divide(dividend, generator);
        return message + remainder;
    }

    static boolean checkCodeWord(String codeword, String generator) {
        String temp = divide(codeword, generator);
        int len = temp.length();
        for (int i = 0; i < len; i++) {
            if (temp.charAt(i) == '1') {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter Generator String");
        String generator = scanner.next();

        while (true) {
            System.out.println("\nMenu");
            System.out.println("1. Generate Code Word");
            System.out.println("2. Check Code Word");
            System.out.println("3. Exit");
            int choice = scanner.nextInt();

            switch (choice) {
            case 1:
                System.out.println("Enter Message");
                String message = scanner.next();
                String result = generateCodeWord(message, generator);
                System.out.println("CodeWord: " + result);
                break;
            case 2:
                System.out.println("Enter Code Word");
                String codeWord = scanner.next();
                if (checkCodeWord(codeWord, generator)) {
                    System.out.println("Code Word is Valid");
                } else {
                    System.out.println("Code Word is Invalid");
                }
                break;
            case 3:
                System.exit(0);
            }
        }
    }
}

////////////
// Output
//
// Enter Generator String
// 1011
//
// Menu
// 1. Generate Code Word
// 2. Check Code Word
// 3. Exit
// 1
// Enter Message
// 1001
// CodeWord: 1001110
//
// Menu
// 1. Generate Code Word
// 2. Check Code Word
// 3. Exit
// 2
// Enter Code Word
// 1001110
// Code Word is Valid
//
// Menu
// 1. Generate Code Word
// 2. Check Code Word
// 3. Exit
// 3

/*
8. Write a program to find the shortest path between vertices using bellman-ford
algorithm.
*/

import java.util.Scanner;

class BellmanFord {

    static int n, dest;
    static double[] prevDistanceVector, distanceVector;
    static double[][] adjacencyMatrix;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter number of nodes");
        n = scanner.nextInt();
        adjacencyMatrix = new double[n][n];

        System.out.println("Enter Adjacency Matrix (Use 'Infinity' for No Link)");
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                adjacencyMatrix[i][j] = scanner.nextDouble();

        System.out.println("Enter destination vertex");
        dest = scanner.nextInt();

        distanceVector = new double[n];
        for (int i = 0; i < n; i++)
            distanceVector[i] = Double.POSITIVE_INFINITY;
        distanceVector[dest - 1] = 0;

        bellmanFordAlgorithm();

        System.out.println("Distance Vector");
        for (int i = 0; i < n; i++) {
            if (i == dest - 1) {
                continue;
            }
            System.out.println("Distance from " + (i + 1) + " is " + distanceVector[i]);
        }
        System.out.println();
    }

    static void bellmanFordAlgorithm() {
        for (int i = 0; i < n - 1; i++) {
            prevDistanceVector = distanceVector.clone();
            for (int j = 0; j < n; j++) {
                double min = Double.POSITIVE_INFINITY;
                for (int k = 0; k < n; k++) {
                    if (min > adjacencyMatrix[j][k] + prevDistanceVector[k]) {
                        min = adjacencyMatrix[j][k] + prevDistanceVector[k];
                    }
                }
                distanceVector[j] = min;
            }
        }
    }
}

////////////
// Output
//
// Enter number of nodes
// 6
// Enter Adjacency Matrix (Use 'Infinity' for No Link)
// 0 3 2 5 Infinity Infinity
// 3 0 Infinity 1 4 Infinity
// 2 Infinity 0 2 Infinity 1
// 5 1 2 0 3 Infinity
// Infinity 4 Infinity 3 0 2
// Infinity Infinity 1 Infinity 2 0
// Enter destination vertex
// 6
// Distance Vector
// Distance from 1 is 3.0
// Distance from 2 is 4.0
// Distance from 3 is 1.0
// Distance from 4 is 3.0
// Distance from 5 is 2.0


/*
9. Using TCP/IP sockets, write a client – server program to make the client send the file
name and to make the server send back the contents of the requested file if present.
*/

import java.net.Socket;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Scanner;

class Client {

    public static void main(String[] args) {
        try {
            Socket socket = new Socket("127.0.0.1", 1300);
            Scanner socketScanner = new Scanner(socket.getInputStream());
            Scanner consoleScanner = new Scanner(System.in);
            System.out.println("Enter File Name");
            String fileName = consoleScanner.nextLine();
            PrintStream printStream = new PrintStream(socket.getOutputStream());
            printStream.println(fileName);
            while (socketScanner.hasNextLine()) {
                System.out.println(socketScanner.nextLine());
            }
            socket.close();
        } catch (IOException e) {
            System.out.println(e.getMessage());
        }
    }
}


/*
9. Using TCP/IP sockets, write a client – server program to make the client send the file
name and to make the server send back the contents of the requested file if present.
*/

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

class Server {
    public static void main(String[] args) {
        try {
            ServerSocket serverSocket = new ServerSocket(1300);
            Socket socket = serverSocket.accept();
            Scanner socketScanner = new Scanner(socket.getInputStream());
            String fileName = socketScanner.nextLine().trim();
            PrintStream printStream = new PrintStream(socket.getOutputStream());
            File file = new File(fileName);
            if (file.exists()) {
                Scanner fileScanner = new Scanner(file);
                while (fileScanner.hasNextLine()) {
                    printStream.println(fileScanner.nextLine());
                }
            } else {
                printStream.println("ERROR: FILE DOESN'T EXISTS");
            }
            // Keep the server alive for complete transfer of data
            System.in.read();

            socket.close();
            serverSocket.close();
        } catch (IOException e) {

        }
    }
}

/*
10. Write a program on datagram socket for client/server to display the messages on
client side, typed at the server side.
*/

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;

class UdpClient {
    public static void main(String[] args) {
        try {
            DatagramSocket datagramSocket = new DatagramSocket(1234);
            byte[] buffer;
            DatagramPacket datagramPacket;
            System.out.println("Messages Received");
            while (true) {
                buffer = new byte[65535];
                datagramPacket = new DatagramPacket(buffer, buffer.length);
                datagramSocket.receive(datagramPacket);
                String received = new String(buffer).trim();
                System.out.println(received);
                if (received.equalsIgnoreCase("exit")) {
                    datagramSocket.close();
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


/*
10. Write a program on datagram socket for client/server to display the messages on
client side, typed at the server side.
*/

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.util.Scanner;

class UdpServer {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        try {
            DatagramSocket datagramSocket = new DatagramSocket();
            InetAddress clientAddress = InetAddress.getByName("127.0.0.1");
            String line;
            byte[] buffer;
            DatagramPacket datagramPacket;
            System.out.println("Enter Messages to Send");
            while (true) {
                line = scanner.nextLine();
                buffer = line.getBytes();
                datagramPacket = new DatagramPacket(buffer, buffer.length, clientAddress, 1234);
                datagramSocket.send(datagramPacket);
                if (line.equalsIgnoreCase("exit")) {
                    datagramSocket.close();
                    break;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

/*
11. Write a program for simple RSA algorithm to encrypt and decrypt the data.
*/

import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.Scanner;

class RSA {

    static BigInteger p, q, n, phi_n, e, d;
    static SecureRandom secureRandom;
    static int bitLength = 64;

    static String encrypt(String msg) {
        return new BigInteger(msg).modPow(e, n).toString();
    }

    static String decrypt(String cipher) {
        return new BigInteger(cipher).modPow(d, n).toString();
    }

    public static void main(String[] args) {

        Scanner scanner = new Scanner(System.in);

        secureRandom = new SecureRandom();

        p = BigInteger.probablePrime(bitLength, secureRandom);
        q = BigInteger.probablePrime(bitLength, secureRandom);
        n = p.multiply(q);
        phi_n = p.subtract(BigInteger.ONE).multiply(q.subtract(BigInteger.ONE));

        e = BigInteger.probablePrime(bitLength / 2, secureRandom);
        while (e.gcd(phi_n).compareTo(BigInteger.ONE) != 0 && e.compareTo(phi_n) < 0) {
            e = e.add(BigInteger.ONE);
        }

        d = e.modInverse(phi_n);

        System.out.println("P assigned as: " + p);
        System.out.println("Q assigned as: " + q);
        System.out.println("N assigned as: " + n);
        System.out.println("PHI_N assigned as: " + phi_n);

        System.out.println("\nEnter Message");
        String msg = scanner.next();

        String encryptedMessage = encrypt(msg);
        System.out.println("Encrypted Message: " + encryptedMessage);

        String decryptedMessage = decrypt(encryptedMessage);
        System.out.println("Decrypted Message: " + decryptedMessage);

    }
}

////////////
// Output
// P assigned as: 635469119130037
// Q assigned as: 954033057154061
// N assigned as: 606258546450627387595401630257
// PHI_N assigned as: 606258546450625798093225346160
//
// Enter Message
// 45465
// Encrypted Message: 581551797190538649820014908031
// Decrypted Message: 45465


/*
12. Write a program for congestion control using leaky bucket algorithm.   
*/

import java.util.Scanner;
import java.util.TreeSet;

class LeakyBucket {
    public static void main(String[] args) {
        TreeSet<Integer> arrivalTimes = new TreeSet<Integer>();
        Scanner scanner = new Scanner(System.in);

        System.out.println("Enter Burstiness in Network");
        int L = scanner.nextInt();

        System.out.println("Enter Packet Inter Arrival");
        int I = scanner.nextInt();

        System.out.println("Enter Arrival Times of Packets (Enter non integer value at end)");
        while (scanner.hasNextInt()) {
            arrivalTimes.add(scanner.nextInt());
        }

        int LCT = arrivalTimes.first();
        int X = 0;

        for (Integer t : arrivalTimes) {
            int temp = X - (t - LCT);
            if (temp > L) {
                System.out.println("Packet at time " + t + " is Non Conforming");
            } else {
                X = temp + I;
                LCT = t;
                System.out.println("Packet at time " + t + " is Conforming");
            }
        }
    }
}

////////////
// Output
// Enter Burstiness in Network
// 6
// Enter Packet Inter Arrival
// 4
// Enter Arrival Times of Packets (Enter non integer value at end)
// 1 2 3 5 6 8 11 12 13 15 19 q
// Packet at time 1 is Conforming
// Packet at time 2 is Conforming
// Packet at time 3 is Conforming
// Packet at time 5 is Non Conforming
// Packet at time 6 is Non Conforming
// Packet at time 8 is Conforming
// Packet at time 11 is Conforming
// Packet at time 12 is Non Conforming
// Packet at time 13 is Non Conforming
// Packet at time 15 is Conforming
// Packet at time 19 is Conforming
